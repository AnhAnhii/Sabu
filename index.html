<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>蓝色爱心粒子 · Blue Heart Particles</title>
  <style>
    /* Toàn màn hình, nền đen */
    html, body {
      margin: 0;
      height: 100%;
      background: #000;
      overflow: hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }
    canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
    }
    /* Dòng chữ giữa màn hình, mờ dần (giống ảnh bạn gửi) */
    p {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%,-50%);
      color: #ff9ecb;            /* hồng nhạt */
      margin: 0;
      animation: k 1.5s ease-in-out infinite;
      pointer-events: none;
      user-select: none;
    }
    @keyframes k {
      0%   { font-size: 18px; opacity: .9; }
      100% { font-size: 24px; opacity: 0; }
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <!-- muốn tắt chữ, xoá <p> này -->
  <p>❤</p>

  <script>
  // ----- Cấu hình theo ảnh gốc -----
  const settings = {
    particles: {
      length: 600,   // số hạt
      duration: 2,   // thời gian sống (s) — nhỏ thì bay nhanh
      velocity: 100, // tốc độ ban đầu
      effect: -0.75, // gia tốc theo hướng vận tốc (âm → chậm dần / co lại)
      size: 32       // kích thước texture hạt (px)
    },
    colors: {
      particle: "#33aaff"  // màu xanh dương (蓝色)
    }
  };

  // Polyfill requestAnimationFrame (để giống script gốc)
  (function() {
    let lastTime = 0;
    const vendors = ['ms','moz','webkit','o'];
    for (let x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
      window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
      window.cancelAnimationFrame =
        window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];
    }
    if (!window.requestAnimationFrame) {
      window.requestAnimationFrame = function(callback) {
        const currTime = performance.now();
        const timeToCall = Math.max(0, 16 - (currTime - lastTime));
        const id = window.setTimeout(() => callback(currTime + timeToCall), timeToCall);
        lastTime = currTime + timeToCall;
        return id;
      };
    }
    if (!window.cancelAnimationFrame) {
      window.cancelAnimationFrame = function(id) { clearTimeout(id); };
    }
  }());

  // ----- Vector 2D đơn giản (Point) -----
  function Point(x, y) {
    this.x = (typeof x !== 'undefined') ? x : 0;
    this.y = (typeof y !== 'undefined') ? y : 0;
  }
  Point.prototype.clone = function() { return new Point(this.x, this.y); };
  Point.prototype.length = function(len) {
    if (typeof len === 'undefined') return Math.hypot(this.x, this.y);
    this.normalize();
    this.x *= len; this.y *= len;
    return this;
  };
  Point.prototype.normalize = function() {
    const l = this.length();
    if (l !== 0) { this.x /= l; this.y /= l; }
    return this;
  };

  // ----- Hạt -----
  function Particle() {
    this.position = new Point();
    this.velocity = new Point();
    this.acceleration = new Point();
    this.age = 0;
  }
  Particle.prototype.initialize = function(x, y, dx, dy) {
    this.position.x = x;   this.position.y = y;
    this.velocity.x = dx;  this.velocity.y = dy;
    this.acceleration.x = dx * settings.particles.effect;
    this.acceleration.y = dy * settings.particles.effect;
    this.age = 0;
  };
  Particle.prototype.update = function(deltaTime) {
    this.velocity.x += this.acceleration.x * deltaTime;
    this.velocity.y += this.acceleration.y * deltaTime;
    this.position.x += this.velocity.x * deltaTime;
    this.position.y += this.velocity.y * deltaTime;
    this.age += deltaTime;
  };
  Particle.prototype.draw = function(ctx, image) {
    // ease-out cubic giống script trong ảnh: (--t)*t*t+1
    function ease(t){ return (--t)*t*t + 1; }
    const life = this.age / settings.particles.duration;
    const size = image.width * ease(life);
    ctx.globalAlpha = 1 - life;
    ctx.drawImage(
      image,
      this.position.x - size / 2,
      this.position.y - size / 2,
      size, size
    );
  };

  // ----- Bể hạt tuần hoàn (ParticlePool) -----
  function ParticlePool(length) {
    this.particles = new Array(length);
    for (let i = 0; i < length; i++) this.particles[i] = new Particle();
    this.firstActive = 0;
    this.firstFree = 0;
    this.duration = settings.particles.duration;
  }
  ParticlePool.prototype.add = function(x, y, dx, dy) {
    this.particles[this.firstFree].initialize(x, y, dx, dy);
    // di chuyển con trỏ
    this.firstFree++;
    if (this.firstFree === this.particles.length) this.firstFree = 0;
    if (this.firstActive === this.firstFree) {
      this.firstActive++;
      if (this.firstActive === this.particles.length) this.firstActive = 0;
    }
  };
  ParticlePool.prototype.update = function(dt) {
    // xoá các hạt đã “chết” ở đầu
    if (this.firstActive !== this.firstFree) {
      let i = this.firstActive;
      while (i !== this.firstFree) {
        const p = this.particles[i];
        p.update(dt);
        if (p.age >= this.duration) {
          this.firstActive++;
          if (this.firstActive === this.particles.length) this.firstActive = 0;
        } else break;
        i = this.firstActive;
      }
    }
  };
  ParticlePool.prototype.draw = function(ctx, image) {
    if (this.firstActive === this.firstFree) return;
    let i = this.firstActive;
    while (i !== this.firstFree) {
      this.particles[i].draw(ctx, image);
      i++; if (i === this.particles.length) i = 0;
    }
  };

  // ----- Heart parametric -----
  function pointOnHeart(t) {
    // Trái tim “cổ điển” (giống Python), sẽ scale sau
    return new Point(
      16 * Math.pow(Math.sin(t), 3),
      13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)
    );
  }

  // ----- Vẽ texture hạt hình trái tim nhỏ -----
  function createHeartImage(size) {
    const c = document.createElement('canvas');
    c.width = c.height = size;
    const ctx = c.getContext('2d');
    ctx.fillStyle = settings.colors.particle;

    ctx.beginPath();
    // Heart path (tỉ lệ 0..1 → -1..1)
    const s = size / 32; // scale nhẹ cho nét đẹp
    ctx.translate(size/2, size/2);
    ctx.scale(s, s);
    ctx.moveTo(0, 0);
    for (let t = -Math.PI; t < Math.PI; t += 0.01) {
      const p = pointOnHeart(t);
      ctx.lineTo(p.x, -p.y); // -y vì canvas trục y xuống dưới
    }
    ctx.closePath();
    ctx.fill();

    return c;
  }

  // ----- Canvas / kích thước -----
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  let width, height, cx, cy, scale, image, pool, emitRate, maxParticles;

  function resize() {
    width  = canvas.width  = window.innerWidth;
    height = canvas.height = window.innerHeight;
    cx = width / 2;
    cy = height / 2;

    // scale trái tim theo cạnh ngắn
    scale = Math.min(width, height) / 40;
    image = createHeartImage(settings.particles.size);

    // chuẩn bị bể hạt
    maxParticles = settings.particles.length;
    pool = new ParticlePool(maxParticles);
    emitRate = maxParticles / settings.particles.duration; // số hạt/s để duy trì
  }
  window.addEventListener('resize', resize);
  resize();

  // ----- Emit & render loop -----
  let prev = performance.now();
  (function frame(now) {
    requestAnimationFrame(frame);
    const dt = Math.min(0.032, (now - prev) / 1000); // clamp 32ms
    prev = now;

    // số hạt phát sinh trong frame này
    const amount = emitRate * dt;

    for (let i = 0; i < amount; i++) {
      // chọn 1 điểm trên trái tim
      const t = Math.random() * 2 * Math.PI;
      const pos = pointOnHeart(t);
      const x = cx + pos.x * scale;
      const y = cy - pos.y * scale;

      // hướng vận tốc ra ngoài theo vector tâm→pos
      const dir = pos.clone().normalize().length(settings.particles.velocity);
      pool.add(x, y, dir.x, -dir.y); // -y vì canvas trục ngược với toán học
    }

    // cập nhật và vẽ
    pool.update(dt);

    ctx.clearRect(0, 0, width, height);
    pool.draw(ctx, image);
    ctx.globalAlpha = 1;
  })(prev);
  </script>
</body>
</html>
