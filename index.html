<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Particle Heart — GIF style</title>
<style>
  html,body{margin:0;height:100%;background:#000;overflow:hidden}
  canvas{position:fixed;inset:0;width:100%;height:100%;display:block}
</style>
</head>
<body>
<canvas id="cv"></canvas>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script>
/* ========= Basic setup ========= */
const rnd=(a,b)=>a+Math.random()*(b-a);
const renderer=new THREE.WebGLRenderer({antialias:true,alpha:false});
renderer.setPixelRatio(Math.min(devicePixelRatio||1,2));
renderer.setSize(innerWidth,innerHeight);
document.body.appendChild(renderer.domElement);

const scene=new THREE.Scene();
const camera=new THREE.PerspectiveCamera(55,innerWidth/innerHeight,0.1,2000);
camera.position.set(0,30,160);
scene.add(new THREE.AmbientLight(0xffffff,1));

addEventListener('resize',()=>{
  renderer.setSize(innerWidth,innerHeight);
  camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix();
});

/* ========= Circle sprite (soft) ========= */
function makeCircle(size=64){
  const c=document.createElement('canvas'); c.width=c.height=size;
  const g=c.getContext('2d'), r=size/2;
  const gr=g.createRadialGradient(r,r,0,r,r,r);
  gr.addColorStop(0,'#fff'); gr.addColorStop(1,'rgba(255,255,255,0)');
  g.fillStyle=gr; g.beginPath(); g.arc(r,r,r,0,6.283); g.fill();
  const tex=new THREE.CanvasTexture(c); tex.anisotropy=8; return tex;
}
const SPRITE = makeCircle();

/* ========= Heart sampling (edge-heavy) ========= */
function heartXY(t){return [16*Math.sin(t)**3, 13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t)];}
function insideHeart(x,y){const xx=x*x,yy=y*y;return Math.pow(xx+yy-1,3)-xx*yy*y<=0;}

const HEART_SCALE=2.8, HEART_Y=38, HEART_POINTS=2800, EDGE_PERCENT=65;
function buildHeartTargets(){
  const pts=[]; const nEdge=Math.floor(HEART_POINTS*EDGE_PERCENT/100), nFill=HEART_POINTS-nEdge;
  for(let i=0;i<nEdge;i++){
    const t=-Math.PI+(i/nEdge)*Math.PI*2; const [hx,hy]=heartXY(t);
    pts.push(new THREE.Vector3(hx*HEART_SCALE+rnd(-.25,.25), hy*HEART_SCALE+HEART_Y+rnd(-.25,.25), rnd(-3,3)));
  }
  for(let i=0;i<nFill;i++){
    const t=rnd(-Math.PI,Math.PI), s=Math.pow(Math.random(),0.35); const [hx,hy]=heartXY(t);
    pts.push(new THREE.Vector3(hx*s*HEART_SCALE+rnd(-.4,.4), hy*s*HEART_SCALE+HEART_Y+rnd(-.4,.4), rnd(-4,4)));
  }
  return pts;
}
const heartTargets=buildHeartTargets();

/* ========= Particles ========= */
const TOTAL=4200; // tổng hạt (đủ mịn)
const positions=new Float32Array(TOTAL*3);
const colors   =new Float32Array(TOTAL*3);

const state=new Array(TOTAL);           // 'float' | 'rise' | 'bound'
const vel=new Array(TOTAL);             // Vector3
const target=new Array(TOTAL);          // index của heartTargets
const boundAge=new Float32Array(TOTAL); // đã giữ bao lâu
const boundHold=new Float32Array(TOTAL);// phải giữ tối thiểu

const blue=new THREE.Color('#8fd9ff');  // lam nhạt (như gif)
const pink=new THREE.Color('#ff5aa0');  // hồng tim trên

// khu vực phun hạt dưới
const bottomY=-40, floorY=-55, radiusX=95, radiusZ=85;
const vortexY=-10, gravity=-25, swirlBase=1.6, updraft=30;

for(let i=0;i<TOTAL;i++){
  const x=rnd(-radiusX,radiusX), y=rnd(floorY,bottomY), z=rnd(-radiusZ,radiusZ);
  positions[i*3]=x; positions[i*3+1]=y; positions[i*3+2]=z;
  const c=blue; colors[i*3]=c.r; colors[i*3+1]=c.g; colors[i*3+2]=c.b;
  state[i]='float'; vel[i]=new THREE.Vector3(rnd(-5,5),rnd(5,15),rnd(-5,5));
  target[i]=-1; boundAge[i]=0; boundHold[i]=0;
}

const geo=new THREE.BufferGeometry();
geo.setAttribute('position', new THREE.BufferAttribute(positions,3));
geo.setAttribute('color',    new THREE.BufferAttribute(colors,3));

/* -- two layers: core + halo (fake glow nhẹ, không chói) -- */
function makeLayer(size,opacity){
  return new THREE.Points(geo, new THREE.PointsMaterial({
    size, sizeAttenuation:true, map:SPRITE, alphaTest:.1, transparent:true, opacity,
    vertexColors:true, blending:THREE.AdditiveBlending, depthWrite:false
  }));
}
const layerCore = makeLayer(8,1.0);     // chấm chính
const layerHalo = makeLayer(14,0.25);   // quầng mờ nhẹ
scene.add(layerHalo); scene.add(layerCore);

/* ========= Vortex field ========= */
function vortexField(x,y,z,strength=1){
  const dx=x, dy=y-vortexY, dz=z;
  const r=Math.max(5, Math.hypot(dx,dz));
  const fall=Math.exp(-(r*r)/9000);
  const tx=(dz/r), tz=-(dx/r);
  const swirl=swirlBase*strength*fall;
  const pull=-0.55*strength*fall;
  const lift=updraft*strength*(0.6+0.4*Math.exp(-(dy*dy)/400));
  return {
    vx: tx*swirl + (dx/r)*pull + (Math.random()-0.5)*0.08,
    vy: 0.33*swirl + lift*0.02 + (Math.random()-0.5)*0.05,
    vz: tz*swirl + (dz/r)*pull + (Math.random()-0.5)*0.08
  };
}

/* ========= Animate ========= */
let last=performance.now(), phase=0;
function animate(now){
  requestAnimationFrame(animate);
  const dt=Math.min(0.04,(now-last)/1000); last=now;

  // camera sway nhẹ
  camera.position.x=Math.sin(now*0.00025)*28;
  camera.position.z=160+Math.cos(now*0.00025)*14;
  camera.lookAt(0,HEART_Y,0);

  // nhịp xoáy lên theo chu kỳ
  const period=7.2; phase=(phase+dt/period)%1;
  const pulse=0.85+0.45*Math.sin(phase*6.283); // 0.4..1.3
  const strength=pulse; // không slider

  for(let i=0;i<TOTAL;i++){
    let x=positions[i*3], y=positions[i*3+1], z=positions[i*3+2];

    if(state[i]==='float'){                  // dưới đáy
      const f=vortexField(x,y,z,strength*0.6);
      vel[i].x+=f.vx; vel[i].y+=gravity*0.02+f.vy; vel[i].z+=f.vz;
      vel[i].multiplyScalar(0.986);
      x+=vel[i].x*dt; y+=vel[i].y*dt; z+=vel[i].z*dt;
      if(y>0 && Math.random()<0.028) state[i]='rise';

    }else if(state[i]==='rise'){            // bị cuốn lên
      const f=vortexField(x,y,z,strength*1.35);
      vel[i].x+=f.vx; vel[i].y+=f.vy+0.65; vel[i].z+=f.vz;
      vel[i].multiplyScalar(0.986);
      x+=vel[i].x*dt*1.45; y+=vel[i].y*dt*1.45; z+=vel[i].z*dt*1.45;

      if(y>HEART_Y-6){                      // vào vùng tim
        state[i]='bound';
        target[i]=(Math.random()*heartTargets.length)|0;
        colors[i*3]=pink.r; colors[i*3+1]=pink.g; colors[i*3+2]=pink.b; // sang hồng
        boundAge[i]=0;
        boundHold[i]=3.6 + Math.random()*1.2;  // giữ lâu giống gif
      }

    }else{                                   // bám hình trái tim
      boundAge[i]+=dt;
      const t=heartTargets[target[i]], k=4.3, damp=0.90;
      vel[i].x+=(t.x-x)*k*dt; vel[i].y+=(t.y-y)*k*dt; vel[i].z+=(t.z-z)*k*dt;

      // nhiễu rất nhẹ để “sống” nhưng không phá hình
      const f=vortexField(x,y,z,strength*0.15);
      vel[i].x+=f.vx*0.22; vel[i].y+=f.vy*0.10; vel[i].z+=f.vz*0.22;

      vel[i].multiplyScalar(damp);
      x+=vel[i].x*dt; y+=vel[i].y*dt; z+=vel[i].z*dt;

      // thỉnh thoảng cho rơi để vòng lặp mượt (sau khi đã giữ đủ)
      if(boundAge[i]>boundHold[i] && phase>0.85 && Math.random()<0.012){
        state[i]='float'; target[i]=-1;
        const c=blue; colors[i*3]=c.r; colors[i*3+1]=c.g; colors[i*3+2]=c.b;
        x=rnd(-radiusX,radiusX); y=rnd(floorY,bottomY); z=rnd(-radiusZ,radiusZ);
        vel[i].set(rnd(-5,5),rnd(5,15),rnd(-5,5));
      }
    }

    // nếu bay khỏi khung → tái sinh dưới
    if(y<floorY-20 || Math.abs(x)>230 || Math.abs(z)>230){
      state[i]='float'; target[i]=-1;
      const c=blue; colors[i*3]=c.r; colors[i*3+1]=c.g; colors[i*3+2]=c.b;
      x=rnd(-radiusX,radiusX); y=rnd(floorY,bottomY); z=rnd(-radiusZ,radiusZ);
      vel[i].set(rnd(-5,5),rnd(5,15),rnd(-5,5));
    }

    positions[i*3]=x; positions[i*3+1]=y; positions[i*3+2]=z;
  }

  geo.attributes.position.needsUpdate=true;
  geo.attributes.color.needsUpdate=true;
  renderer.render(scene,camera);
}
requestAnimationFrame(animate);
</script>
</body>
</html>
